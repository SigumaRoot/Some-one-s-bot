"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const UndefinedValidator_1 = __importDefault(require("./UndefinedValidator"));
const Validator_1 = __importDefault(require("../classes/Validator"));
class ObjectValidator extends Validator_1.default {
    static MISSING_PROPERTY = `Object requires this property but is missing`;
    static UNKNOWN_PROPERTY = `Object has unknown property which is defined`;
    rule_object;
    constructor(rule_object) {
        super();
        this.rule_object = rule_object;
        if (rule_object) {
            if (Object.keys(rule_object).length === 0) {
                this.schema = `{"$type":"object"}`;
            }
            else {
                this.schema = `{"$type":"object","$properties":{`;
                for (const rule_key in rule_object) {
                    const rule_value = rule_object[rule_key];
                    this.schema += `"${rule_key}":${rule_value.schema},`;
                }
                this.schema = this.schema.slice(0, -1);
                this.schema += `}}`;
            }
        }
        else {
            this.schema = `{"$type":"object","$properties":{"$any":{"$type":"any"}}}`;
        }
    }
    validate(data, locator) {
        if (typeof data !== "object" || Array.isArray(data) || data === null) {
            return this.failure(locator, Validator_1.default.WRONG_TYPE, this, data);
        }
        if (!this.rule_object)
            return this.success(data);
        let result = this.success(data);
        for (const [ruleKey, ruleValue] of Object.entries(this.rule_object)) {
            const traversedLocator = locator.traverse(ruleKey);
            const ruleRejectsUndefined = !ruleValue.validate(undefined, traversedLocator).success;
            if (!Object.keys(data).includes(ruleKey) && ruleRejectsUndefined) {
                result = {
                    success: false,
                    errors: [
                        ...result.errors,
                        ...this.failure(traversedLocator, ObjectValidator.MISSING_PROPERTY, ruleValue, undefined).errors
                    ],
                    data: undefined
                };
            }
        }
        for (const [dataKey, dataValue] of Object.entries(data)) {
            const traversedLocator = locator.traverse(dataKey);
            const rule = this.rule_object[dataKey];
            if (!rule) {
                result = {
                    success: false,
                    errors: [
                        ...result.errors,
                        ...this.failure(traversedLocator, ObjectValidator.UNKNOWN_PROPERTY, new UndefinedValidator_1.default(), dataValue).errors
                    ],
                    data: undefined
                };
                continue;
            }
            if (!rule.validate(dataValue, traversedLocator).success) {
                result = {
                    success: false,
                    errors: [
                        ...result.errors,
                        ...this.failure(traversedLocator, Validator_1.default.WRONG_TYPE, rule, dataValue).errors
                    ],
                    data: undefined
                };
            }
        }
        return result;
    }
}
exports.default = ObjectValidator;
